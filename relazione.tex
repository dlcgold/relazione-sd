\documentclass[a4paper,12pt, oneside]{book}

%\usepackage{fullpage}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{engrec}
\usepackage{rotating}
\usepackage[safe,extra]{tipa}
\usepackage{showkeys}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage{enumerate}
\usepackage{braket}
\usepackage{marginnote}
\usepackage{pgfplots}
\usepackage{cancel}
\usepackage{polynom}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{pdfpages}
\usepackage{pgfplots}
\usepackage[cache=false]{minted}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}
\fancyfoot[C]{\thepage}



\title{BrainJobs}
\author{UniShare\\\\Davide Cozzi\\\href{https://t.me/dlcgold}{@dlcgold}\\\\Gabriele De Rosa\\\href{https://t.me/derogab}{@derogab}}}
\date{}

\pgfplotsset{compat=1.13}
\begin{document}
\maketitle

\definecolor{shadecolor}{gray}{0.80}

\newtheorem{teorema}{Teorema}
\newtheorem{definizione}{Definizione}
\newtheorem{esempio}{Esempio}
\newtheorem{corollario}{Corollario}
\newtheorem{lemma}{Lemma}
\newtheorem{osservazione}{Osservazione}
\newtheorem{nota}{Nota}
\newtheorem{esercizio}{Esercizio}
\tableofcontents
\renewcommand{\chaptermark}[1]{%
	\markboth{\chaptername
		\ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}

\chapter{Introduzione}
BrainJobs è un (ipotetico) servizio cloud di tipo Software-as-a-Service (SaaS) che offre ai
suoi utenti la possibilità di “allenare” modelli di apprendimento automatico, di valutarne le
prestazioni ed (eventualmente) riutilizzarli per effettuare simulazioni.
Il sistema permette agli utenti di effettuare richieste di allenamento o simulazione caricando i
dati insieme al modello o utilizzandone uno già precedentemente allenato e salvato nel
proprio archivio. In base al linguaggio o al framework utilizzato per il codice del modello,
BrainJobs lancia la computazione in un particolare ambiente di esecuzione che verrà
istanziato “on-the-fly” in un’altra piattaforma cloud di tipo Serverless basata su containers
(es: Apache OpenWhisk, Knative, ...).
Gli utenti possono sottomettere più richieste consecutive. Esse verranno gestite in parallelo
in un sistema a coda. Ogni richiesta di un utente corrisponde ad un task di lavoro (job).
Gli utenti possono controllare lo stato delle loro richieste dalla dashboard di BrainJobs, ed
una volta terminate, visualizzarne i risultati. Successivamente, il sistema permette di scartare
o salvare il modello per utilizzi futuri.
L’architettura del servizio BrainJobs è suddivisa in tanti servizi e componenti, ognuno con un
compito ben specifico. Al vostro team, è richiesta la creazione di due componenti:
\begin{enumerate}
\item un componente di frontend implementato utilizzando HTML, CSS e JavaScript che
  utilizza il paradigma AJAX per inviare/ricevere dati
\item un componente di backend che espone una HTTP API REST
\end{enumerate}
Il frontend deve permettere ad un utente di creare una nuova richiesta di allenamento,
visualizzare la lista delle sue richieste e visualizzare le informazioni di dettaglio di ogni
richiesta.
Il backend deve essere in grado di salvare una nuova richiesta, fornire la lista delle richieste
di un utente e restituire informazioni di dettaglio di ogni richiesta.
Una volta che il backend ha salvato una nuova richiesta, altri servizi di BrainJobs si
occuperanno di lanciare la computazione, aggiornare lo stato del job ed aggiungere i
risultati.\\
\begin{figure}[h!]
  \centering
  \includegraphics[scale = 0.7]{img/struttura.png}
  \caption{struttura finale del progetto}
\end{figure}
\chapter{FrontEnd}
Iniziamo parlando del frontend. Per quanto riguarda l'aspetto estetico è stato usato un tema di Bootstrap
per poter rappresentare più semplicemente componenti come il menù presente nella parte alta
della pagina, contenente le informazioni del progetto, e la navbar con il bottone per richiamare il menù. Entrambi componenti sono nel tag \textit{header}.

\begin{figure}[h!]
  \centering
  \includegraphics[scale = 0.385]{img/navbar.png}
  \caption{navbar}
\end{figure}
\begin{figure}[h!]
  \centering
  \includegraphics[scale = 0.385]{img/menu.png}
  \caption{menù a scomparsa}
\end{figure}

\textbf{navbar}:
\begin{shaded}
\begin{minted}{html}
<div class="navbar navbar-dark bg-dark shadow-sm">
 <div class="container d-flex justify-content-between">
  <a href="#" class="navbar-brand d-flex align-items-center">
   <strong><i class="fas fa-brain"></i> BrainJobs</strong>
   </a>
   
  <button class="navbar-toggler" type="button"
    data-toggle="collapse"
    data-target="#navbarHeader" aria-controls="navbarHeader"
    aria-expanded="false" aria-label="Toggle navigation">
   <span class="navbar-toggler-icon"></span>
  </button>
 </div>
</div>
\end{minted}
\end{shaded}
\textbf{Menù:}
\begin{shaded}
\begin{minted}{html}
<div class="collapse bg-dark" id="navbarHeader">
 <div class="container">
  <div class="row">
   <div class="col-sm-8 col-md-7 py-4">
    <h4 class="text-white">Informazioni</h4>
    <p class="text-muted">
     Progetto del corso di Sistemi Distribuiti dell'anno
      accademico 2018/19 all'università degli studi di
       Milano-Bicocca.
    </p>
   </div>
   <div class="col-sm-4 offset-md-1 py-4">
    <h4 class="text-white">Crediti</h4>
     <ul class="list-unstyled">
      <li><a class="text-white"
       href="https://www.github.com/dlcgold">
        Davide Cozzi</a></li>
      <li><a class="text-white"
       href="https://www.github.com/derogab">
        Gabriele De Rosa</a></li>
     </ul>
    </div>
   </div>
  </div>
</div>
\end{minted}
\end{shaded}
Si passa poi alla sezione con il titolo della pagina, con l'icona presa da quella
messe a disposizione sul sito \url{https://fontawesome.com/icons/}:
\begin{figure}[h!]
  \centering
  \includegraphics[scale = 0.8]{img/titolo.png}
  \caption{titolo della pagina}
\end{figure}
\begin{shaded}
\begin{minted}{html}
<section class="jumbotron text-center">
 <div class="container">
  <h1 class="jumbotron-heading"><i class="fas fa-brain"></i>
   BrainJobs</h1>
 </div>
</section>
\end{minted}
\end{shaded}
Analizziamo ora una delle parti principali della pagina: \textbf{il form di inserimento dati}. Qui si è fatto uso della classe \textit{form-group} per impostare i
vari campi del form, con titolo e \textit{form-control} per l'inserimento, e della
classe \textit{custom-select} per quei campi con selezione obbligatoria,
dove quindi è stato aggiunto un selettore:
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.7]{img/form.png}
  \caption{form per l'inserimento della richiesta}
\end{figure}
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.7]{img/selettore.png}
  \caption{esempio di selettore}
\end{figure}

Vediamo quindi, per esempio, la parte nell'\textit{index.html} dedicata all'inseriemnto di \textit{title}, ovvero un inserimento manuale senza selettore:
\begin{shaded}
\begin{minted}{html}
<div class="row">
 <div class="col-md-2 col-sm-12">
  <label for="title">title</label>
 </div>
 <div class="col-md-10 col-sm-12">
  <input type="text" class="form-control" id="title"
   placeholder="Inserisci title (obbligatorio)">
 </div>
</div>
\end{minted}
\end{shaded}
Dove notiamo come le classi \textit{col-md-n} e \textit{col-sm-n} permettono di rendere \textit{responsive} gli elementi (la stringa e il box di inserimento).
\newpage
Passiamo ora a vedere l'esempio di un inserimento mediante selettore, prendendo come esempio
l'inserimento del framework:
\begin{shaded}
\begin{minted}{html}
<div class="form-group">
 <div class="row">
  <div class="col-md-2 col-sm-12">
   <label for="framework">framework</label>
  </div>
  <div class="col-md-10 col-sm-12">
   <select class="custom-select" class="form-control"
     id="framework">
    <option selected></option>
    <option value="pytorch">Pytorch</option>
    <option value="tensorflow">Tensorflow</option>
    <option value="caffe">Caffe</option>
    <option value="keras">Keras</option>
    <option value="deeplearning4j">Deeplearning4j</option>
    <option value="apache_mahout">Apache_mahout</option>
    <option value="apache_singa">Apache_singa</option>
   </select>
  </div>
 </div>
</div>
\end{minted}
\end{shaded}
Analizziamo ora la seconda parte fondamentale della pagina, dove l'utente può
inserire uno \textit{user\_id} o un \textit{job\_id} per effettuare una query nel database
delle richieste:
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.8]{img/query.png}
  \caption{campi per l'inserimento di query}
\end{figure}
\newpage
Nell'\textit{index.html} si ha quindi:
\begin{shaded}
\begin{minted}{html}
<h3>Dettagli</h3>

<h6>Richieste di uno user</h6>
 <div class="row">
  <div class="col-md-6">
   <input type="text" class="form-control"
     id="user_id_search"
      placeholder="Inserisci lo user_id">
  </div>
  <div class="col-md-6">
   <button id="get-all-requests"
     class="btn btn-dark btn-block">
      Visualizza le richieste di user</button>
  </div>
 </div>

 <h6 style="margin-top: 10px;">Richiesta singola</h6>
 <div class="row">
  <div class="col-md-6">
   <input type="text" class="form-control"
     id="job_id" placeholder="Inserisci job_id">
  </div>
  <div class="col-md-6">
   <button id="get-single-request"
    class="btn btn-dark btn-block">
     Visualizza la richiesta</button>
  </div>
 </div>
\end{minted}
\end{shaded}
infine i risulati della query verranno visualizzati mediante:
\begin{shaded}
\begin{minted}{html}
<div id="results"></div>
\end{minted}
\end{shaded}
\newpage
Infine una parola per tutta quella parte del file dedicata al permettere l'uso di \textit{bootstrap}, \textit{jquery}
e del \textit{custom.js} mediante il quale, con l'uso di \textbf{ajax}, sono state fatte le \textit{POST} e le \textit{GET}:
\begin{shaded}
\begin{minted}{html}
<!-- nell'HEAD -->
    
<!-- Bootstrap core CSS -->
<link href="css/bootstrap.min.css" rel="stylesheet">

<!-- FA -->
<link href="css/fa.css" rel="stylesheet">

<!-- Custom styles for this template -->
<link href="css/custom.css" rel="stylesheet">

...


<!-- alla fine del file -->

<!-- jQuery -->
<script src="js/jquery.min.js"></script>
<script>window.jQuery ||
 document.write('<script src="js/jquery.min.js">
  <\/script>')</script>
    
<!-- Bootstrap bundle JS -->
<script src="js/bootstrap.bundle.min.js"></script>

<!-- Custom javascript script w/ ajax requests-->
<script src="js/custom.js"></script>
\end{minted}
\end{shaded}
Come footer si ha l'icona del copyright e un ``torna su'' che è collegato ad un'ancora all'inizio dell'html:
\begin{shaded}
\begin{minted}{html}
<footer class="text-muted">
 <div class="container">
  <p class="float-right">
   <a href="#">Torna su</a>
  </p>
  <p><i class="far fa-copyright"></i> BrainJobs 2019</p>
 </div>
</footer>
\end{minted}
\end{shaded}
Abbiamo visto il file \textit{HTML} ma questo non basta in quanto serve il \textit{custom.js} per interagire, mediante jquery e ajax, con il backend. Si ha quindi la seguente struttura per il \textbf{frontend}:
\begin{shaded}
\begin{minted}{shell}
.
├── css:
│   ├── bootstrap.css
│   ├── bootstrap.css.map
│   ├── bootstrap-grid.css
│   ├── bootstrap-grid.css.map
│   ├── bootstrap-grid.min.css
│   ├── bootstrap-grid.min.css.map
│   ├── bootstrap.min.css
│   ├── bootstrap.min.css.map
│   ├── bootstrap-reboot.css
│   ├── bootstrap-reboot.css.map
│   ├── bootstrap-reboot.min.css
│   ├── bootstrap-reboot.min.css.map
│   ├── custom.css
│   ├── fa.css
│   └── fa.min.css
├── index.html
├── js:
│   ├── bootstrap.bundle.js
│   ├── bootstrap.bundle.js.map
│   ├── bootstrap.bundle.min.js
│   ├── bootstrap.bundle.min.js.map
│   ├── bootstrap.js
│   ├── bootstrap.js.map
│   ├── bootstrap.min.js
│   ├── bootstrap.min.js.map
│   ├── custom.js
│   ├── fa.js
│   ├── fa.min.js
│   ├── jquery.js
│   └── jquery.min.js
└── webfonts:
    ├── fa-brands-400.eot
    ├── fa-brands-400.svg
    ├── fa-brands-400.ttf
    ├── fa-brands-400.woff
    ├── fa-brands-400.woff2
    ├── fa-regular-400.eot
    ├── fa-regular-400.svg
    ├── fa-regular-400.ttf
    ├── fa-regular-400.woff
    ├── fa-regular-400.woff2
    ├── fa-solid-900.eot
    ├── fa-solid-900.svg
    ├── fa-solid-900.ttf
    ├── fa-solid-900.woff
    └── fa-solid-900.woff2
\end{minted}
\end{shaded}
con tutti i file per la parte di CSS, tutto il necessario per jquery e bootstrap, i fonts etc...\\
Ci concentriamo ovviamente sul \textit{custom.js} che abbiamo scritto per interfacciare frontend e backend.\\
Aprendo il file notiamo innanzitutto una definizione di costante:
\begin{shaded}
\begin{minted}{js}
const API = "http://localhost:8080/brainjobs-gateway/api/v1/";
\end{minted}
\end{shaded}
questa rappresenta parte del path per i vari endpoint presenti nel gateway.\\
Proseguendo oltre incontriamo la prima funzione di \textbf{jQuery} che controlla che quanto
è contenuto al suo interno venga eseguito unicamente una volta che il \textbf{DOM}
sia pronto per l'esecuzione di codice javascript:
\begin{shaded}
\begin{minted}{js}
$(document).ready(function(){
 ...
});
\end{minted}
\end{shaded}
Passiamo ora ad analizzare le tre operazioni base che vengono effettuate.\\
Nell'\textit{index.html} il bottone associato all'invio di una richiesta
era stato identificato con l'id \textit{send-form} possiamo quindi sfruttare il metodo
\textit{.click()} di jquery per triggerare una funzione \textit{function(e)
} con una sequenza di istruzioni ogni volta che viene clickato il bottone.
Vediamo quindi queste istruzioni nel caso dell'invio del form.\\
Innanzitutto abbiamo un'struzione per prevenire l'azione di default di un evento (\textit{e}), evitando quindi il refresh della pagina:
\begin{shaded}
\begin{minted}{js}
 e.preventDefault();
\end{minted}
\end{shaded}
Definiamo poi una variabile per ogni campo del form sfruttando il metodo di jquery
\textit{.val()} che resituisce il valore di un id, con l'aggiunta del \textit{.trim()} che rimuove eventuali spazi all'inizio e alla fine:
\begin{shaded}
\begin{minted}{js}
 var user_id = $("#user_id").val().trim();
 var title = $("#title").val().trim();
 var language = $("#language").val().trim();
 var framework = $("#framework").val().trim();
 var dataset = $("#dataset").val().trim();
 var dataset_datatype = $("#dataset_datatype").val().trim();
 var model = $("#model").val().trim();
\end{minted}
\end{shaded}
La traccia impone l'obbligo di avere tutti i campi compilati tranne quello riguardante
il framework, che è opzionale. Una if con la condizione che basti l'assenza
di uno dei campi viene usata per restituire, mediante l'id \textit{send-form-result}
e il metodo \textit{.html}, un alert, con un bottone dedicato alla sua chiusura:
\begin{shaded}
\begin{minted}{js}
if (!user_id || !title || !language ||
     !dataset || !dataset_datatype || !model ) { 
$('#send-form-result').html(
   '<div class="alert alert-warning alert-dismissible fade show"
     role="alert">'
     +'<strong>Warning!</strong> Compilare i campi obbligatori.'
     +'<button type="button" class="close"
        data-dismiss="alert" aria-label="Close">'
     +'<span aria-hidden="true">&times;</span>'
     +'</button>'
     +'</div>');
 }
\end{minted}
\end{shaded}
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.7]{img/err-form.png}
  \caption{alert nel caso di form incompleto}
\end{figure}
Nel caso invece di form inserito correttamente si può procedere, mediante l'else, con la richiesta \textbf{ajax}.\\
\begin{shaded}
In informatica AJAX, acronimo di Asynchronous JavaScript and XML, è una tecnica di sviluppo software per la realizzazione di applicazioni web interattive (Rich Internet Application). Lo sviluppo di applicazioni HTML con AJAX si basa su uno scambio di dati in background fra web browser e server, che consente l'aggiornamento dinamico di una pagina web senza esplicito ricaricamento da parte dell'utente.

AJAX è asincrono nel senso che i dati extra sono richiesti al server e caricati in background senza interferire con il comportamento della pagina esistente. Normalmente le funzioni richiamate sono scritte con il linguaggio JavaScript. Tuttavia, e a dispetto del nome, l'uso di JavaScript e di XML non è obbligatorio, come non è detto che le richieste di caricamento debbano essere necessariamente asincrone. 
\end{shaded}
Si usa quindi il metodo \textit{$.ajax()}, a cui viene specificato, mediante il campo
\textit{type}, il tipo di richiesta, mediante il campo \textit{url}, l'endpoint,
mediante il campo \textit{dataType}, il tipo di dato che ci si aspetta dal server,
mediante il campo \textit{data}, i dati che devono essere mandati al server, mediante il campo \textit{success}, la funzione che deve essere eseguita
se la richeista avviene con successo, e, mediante il campo \textit{error}, la funzione da eseguire in caso di errore.\\
Nel nostro caso queste ultime due funzioni sono due alert che avvisano se la richiesta è stata effettuata on successo o meno:
\begin{figure}[H]
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[scale = 0.42]{img/good-form.png}
  \caption{alert in caso di successo}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[scale = 0.4]{img/bad-form.png}
  \caption{alert in caso di errore}
\end{minipage}
\end{figure}
Passiamo ora alla prima delle due query, quella nel quale si inserisce uno \textit{user\_id} per ottenere tutte le richieste da lui effettuate. Come prima procediamo al click sul bottone, stavolta con l'id \textit{get-all-requests}, e salviamo in una variabile lo user_id:

\begin{shaded}
\begin{minted}{js}
$(document).ready(function() {
  var user_id = $("#user_id_search").val().trim();
  e.preventDefault();
  ...
});
\end{minted}
\end{shaded}
Anche qui con un if controlliamo che sia stato effettivamente inserito uno user\_id prima di effettuare la query premendo il bottone e in caso contrario si provvede a stampare un alert dedicato:

\begin{shaded}
\begin{minted}{js}
 if( !user_id ) {
  $('#results').html('<div class="alert alert-warning
    alert-dismissible fade show" role="alert">'
   +'<strong>Warning!</strong> Compila il campo user_id.'
   +'<button type="button" class="close" data-dismiss="alert
    " aria-label="Close">'
   +'<span aria-hidden="true">&times;</span>'
   +'</button>'
   +'</div>');
 }
\end{minted}
\end{shaded}
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.7]{img/bad-user.png}
  \caption{alert nel caso di assenza di inserimento dello user}
\end{figure}
Altrimenti, mediante l'else, effettuiamo una richiesta di tipo \textit{GET} mediante ajax.
Si hanno due casi di successo, il primo se la richiesta avviene correttamente ma non
si hanno richieste per quello user\_id, la seconda se si ha invece almeno una richiesta.
Nel primo caso si controlla che l'array contenente le informazioni abbia lunghezza 0,
in tal caso si stampa un alert.
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.7]{img/no-user.png}
  \caption{alert nel caso di assenza di richieste}
\end{figure}
Nel secondo caso,
mediante il metodo \textit{.each(function)} che permette di iterare su un oggetto
jquery permettendo di eseguire una \textit{function} per ogni elemento, stampo i
vari campi di ogni richiesta che mi viene resitutita dal server salvando progressivamente il tutto in una stringa \textit{result} che verrà associata all'id omonimo nell'\textit{index.html}. \\
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.43]{img/good-user.png}
  \caption{risultati in caso di presenza di richieste}
\end{figure}
In caso di \textit{error} invece si avrà il solito alert:
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.7]{img/bad-user-query.png}
  \caption{alert in caso di errore nella richiesta ajax}
\end{figure}
Per quanto riguarda la seconda query funziona esattamente nella stessa maniera con
l'unica differenza che in caso di presenza di una richiesta con il job\_id idnicato
non si ha alcun \textit{.each()} in quanto si può avere una sola richiesta con quel job\_id:
\begin{shaded}
\begin{minted}{js}
$.ajax({

    type: "GET",
    url: API + 'jobs/' + job_id,
    dataType: "json",
    success: function(data) {
     
     if(!data){
       $('#results').html('<div class="alert alert-warning
        alert-dismissible fade show" role="alert">'
        +'<strong>Warning!</strong> Questo job_id non esiste.'
        +'<button type="button" class="close" data-dismiss="alert"
         aria-label="Close">'
        +'<span aria-hidden="true">&times;</span>'
        +'</button>'
        +'</div>');
     }
     else{

      var result = "";
      result += "user_id: " + data.user_id + " <br> ";
      result += "title: " + data.title + " <br> ";
      result += "language: " + data.language + " <br> ";
      result += "framework: " + data.framework + " <br> ";
      result += "dataset: " + data.dataset + " <br> ";
      result += "dataset_datatype: " +
       data.dataset_datatype + " <br> ";
      result += "model: " + data.model + " <br> ";
      result += "status: " + data.status + " <br> ";
      result += "created_at: " + data.created_at + " <br> ";
      result += "job_id: " + data.job_id + " <br> ";
      result += "<br>";
  
      $('#results').html('<div class="alert alert-info"
        role="alert">'
       +'<strong>Dati richiesti</strong> <br><br>'+result
       +'</div>');

     }
 
    },
    error: function() {
      $('#results').html('<div class="alert alert-danger
       alert-dismissible fade show" role="alert">'
     +'<strong>Errore!</strong> Si è verificato un
      errore durante l\'invio della richiesta.'
      +'<button type="button" class="close" data-dismiss="alert"
       aria-label="Close">'
       +'<span aria-hidden="true">&times;</span>'
      +'</button>'
     +'</div>');
    }
 
   });
\end{minted}
\end{shaded}
\newpage
Si ha quindi:
\begin{figure}[H]
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[scale = 0.42]{img/good-job.png}
  \caption{risultato in caso di successo}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[scale = 0.4]{img/no-job.png}
  \caption{alert mancata presenza di richieste per quel job\_id}
\end{minipage}
\end{figure}
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.7]{img/err-job.png}
  \caption{alert nel caso di errore della richiesta}
\end{figure}
\newpage
Quindi nel complesso la pagina si presenta così:
\begin{figure}[H]
  \centering
  \includegraphics[scale = 0.4]{img/pagina1.png}
  \includegraphics[scale = 0.4]{img/pagina2.png}
  \includegraphics[scale = 0.4]{img/pagina3.png}
  \caption{frontend brainjob}
\end{figure}
\chapter{Backend}
Per il backend ci siamo appoggiati su \textbf{nodejs}:
\begin{shaded}
Node.js è una runtime di JavaScript Open source multipiattaforma orientato agli eventi per l'esecuzione di codice JavaScript Server-side, costruita sul motore JavaScript V8 di Google Chrome. Molti dei suoi moduli base sono scritti in JavaScript, e gli sviluppatori possono scrivere nuovi moduli in JavaScript.

In origine JavaScript veniva utilizzato principalmente lato client. In questo scenario gli script JavaScript, generalmente incorporati all'interno dell'HTML di una pagina web, vengono interpretati da un motore di esecuzione incorporato direttamente all'interno di un Browser. Node.js consente invece di utilizzare JavaScript anche per scrivere codice da eseguire lato server, ad esempio per la produzione del contenuto delle pagine web dinamiche prima che la pagina venga inviata al Browser dell'utente. Node.js in questo modo permette di implementare il cosiddetto paradigma "JavaScript everywhere" (JavaScript ovunque), unificando lo sviluppo di applicazioni Web intorno ad un unico linguaggio di programmazione (JavaScript).

NodeJs ha un'architettura orientata agli eventi che rende possibile l’I/O asincrono. Questo design punta ad ottimizzare il Throughput e la scalabilità nelle applicazioni web con molte operazioni di input/output, è inoltre ottimo per applicazioni web Real-time (ad esempio programmi di comunicazione in tempo reale o browser game).

Node.js è un progetto di sviluppo Open source distribuito gestito dalla Node.js Foundation e facilitato tramite il programma di progetti collaborativi della Linux Foundation. 
\end{shaded}
\newpage
La struttura del backend è la seguente:
\begin{shaded}
\begin{minted}{shell}
brainjobs-backend
│   ├── api
           index.js
│   ├── db.json
│   ├── index.js
│   ├── node_modules
│   ├── package.json
│   └── package-lock.json
\end{minted}
\end{shaded}
Partiamo con l'analizzare l'\textit{index.js} presente subito nella cartella \textit{brainjobs-backend}.
Qui vengono definiti tutti i requisiti necessari per l'uso
delle porte (8082 per il backend e 8081 per il frontend). Come database d'appoggio
è stato scelto \textit{lowdb}, \url{https://github.com/typicode/lowdb}, ovvero
un database minimale basato su file json che consente un facile utilizzo sia per quanto riguarda l'inizializzazione dello stesso che per quanto riguarda le query. All'interno del file viene quindi inizalizzato il file \textit{db.json} e ne vengono settati i valori di default:
\begin{shaded}
\begin{minted}{js}
const low = require('lowdb');
const FileSync = require('lowdb/adapters/FileSync');

const adapter = new FileSync('db.json');
const db = low(adapter);

db.defaults({ requests: [] }).write();
\end{minted}
\end{shaded}
È stato scelto di usare un framework per web application chiamato \textit{express},
\url{https://github.com/expressjs/express}. Usando express è facile istanziare una
web app (usando il metodo \textit{.use()}) con metodi GET e POST. Sempre con express è possibile gestire il frontend
in maniera statica, mediante \textit{express.static()}, (mentre il backend verrà eseguito dinamicamente). Con require
si richiema l'\textit{index.js} contenuto nella sottocartella \textit{/api} al quale viene passato come argomento la web app generata da express e il database.
\begin{shaded}
\begin{minted}{js}
var express = require('express');

// backend
var app_backend = express();
var port_backend = 8082;
// frontend
var app_frontend = express();
var port_frontend = 8081;

console.log('Web Server started.');
console.log('API started on: ' + port_backend);
console.log('Static index on: ' + port_frontend);

// API
require(__dirname + '/api')(app_backend, db);

// FRONT-END
app_frontend.use('/brainjobs-frontend',
 express.static('../brainjobs-frontend/'));
\end{minted}
\end{shaded}
Viene anche usato \textit{body-parse}, \url{https://github.com/expressjs/body-parser}, che parsa il body della richiesta in un middleware, raggiungibile mediante \textit{req.body}, usando il metodo \textit{.urlencoded({options})} per il parsing di dati nel formato \textit{application/x-www-urlencoded}. Il formato\textit{ application/x-www-form-urlencoded} permette di trasmettere i parametri all'interno del contenuto di una request, usando la stessa sintassi che serve a comunicare i parametri nella URL.
\begin{shaded}
\begin{minted}{js}
var bodyParser = require('body-parser');
app_backend.use(bodyParser.urlencoded({ extended: false }));
\end{minted}
\end{shaded}
\newpage
Essendo questo uno dei due file che verranno effettivamente eseguiti si stampano le porte assegnate al backend e al frontend:
\begin{shaded}
\begin{minted}{shell}
brainjobs-backend : node index.js

 Web Server started.
 API started on: 8082
 Static index on: 8081
\end{minted}
\end{shaded}
Passiamo ora al file con le api vere e proprie. Come abbiamo visto viene caricato
passandogli come parametri l'app istanziata da \textit{express} (che gode dei metodi \textit{.get()} e \textit{.post()}) e il database generato mediante \textit{lowdb}. All'inizio avremo quindi:
\begin{shaded}
\begin{minted}{js}
module.exports = function (app, db) {
  ...
};
\end{minted}
\end{shaded}
Sul primo endpoint, \textit{/brainjobs-backend/api/v1/jobs}, abbiamo innazitutto il salvataggio
di una richiesta, mediante il metodo POST. Si ha accesso all'oggetto richiesta con \textit{req} e risposta con \textit{res}
\begin{shaded}
\begin{minted}{js}
app.post("/brainjobs-backend/api/v1/jobs", (req, res) => { 
  ...
});
\end{minted}
\end{shaded}
Viene richiesto di aggiungere ai dati inseriti dall'utente un campo \textit{job\_id} univoco, la data e lo stato della richiesta.
Viene quindi usata una libreria aggiuntiva, \textit{uuid}, nella versione 4, \url{https://github.com/kelektiv/node-uuid}, per generare degli id univoci, infatti uuid sta per \textit{Universally Unique IDentifier}.
\begin{shaded}
\begin{minted}{js}
var uuidv4 = require('uuid/v4');
var job_id = uuidv4();
\end{minted}
\end{shaded}
Per la data di creazione (campo \textit{created\_at}) viene usata la classe \textit{Date} il cui risultato viene parsato in un formato ``human'', composto di giorno, mese e anno.
Il metodo \textit{padstart(n, c)} trasla la stringa fino al raggiungimento di \textit{n}
caratteri aggiungendo in testa la giusta quiantità di caratteri \textit{c}. Quindi prende
mediante il metodo \textit{getDate()} il giorno del mese e, se di una sola cifra,
ci emtte davanti uno 0. Poi con il meotodo \textit{.getMonth()} si ottiene il mese
(ma partendo da 0, che rappresenta Gennaio) al quale viene aggiunto 1, procedendo
poi come per il giorno. Per l'anno si usa banalmente il metodo \textit{getFullYear()}:
\begin{shaded} 
\begin{minted}{js}
var today = new Date();
var dd = String(today.getDate()).padStart(2, '0');
var mm = String(today.getMonth() + 1).padStart(2, '0');
var yyyy = today.getFullYear();
var created_at = dd + '/' + mm + '/' + yyyy;
\end{minted}
\end{shaded}
per quanto riguarda il campo \textit{status} viene aggiunto il valore \textit{created} in quanto è l'unico scenario di successo di questo progetto:
\begin{shaded} 
\begin{minted}{js}
var status = 'created';
\end{minted}
\end{shaded}
Come vedremo dopo il backend non è in diretto contatto con il frontend
ma si ha di mezzo un gateway che nel nostro casso passa una stringa contenente un json al backend.
Si ha quindi il metodo \textit{JSON.parse(string)} per ottenere un oggetto json con i dati della richiesta (quindi solo quelli del campo \textit{req.body} che per comodità vengono assegnati ad una variabile con lo stesso nome):
\begin{shaded} 
\begin{minted}{js}
req.body = JSON.parse(Object.keys(req.body)[0]);  
\end{minted}
\end{shaded}
Viene quindi definito l'oggetto con la richiesta sfruttando appunto \textit{req.body} e i tre campi sopra definiti:
\begin{shaded} 
\begin{minted}{js}
var request = {
  user_id: req.body.user_id,
  title: req.body.title,
  language: req.body.language,
  framework: req.body.framework,
  dataset: req.body.dataset,
  dataset_datatype: req.body.dataset_datatype,
  model: req.body.model,  
  status: status,
  created_at: created_at,
  job_id: job_id
};
\end{minted}
\end{shaded}
SI provvede poi al salvataggio della richiesta nel database sfruttando il metodo \textit{.get(string)} di lowdb che seleziona il campo \textit{request} impostato di default, con il metodo \textit{.push(object)} inserisce l'oggetto json e con il metodo \textit{.write()} scrive nel file:
\begin{shaded} 
\begin{minted}{js}
db.get('requests').push(request).write();
\end{minted}
\end{shaded}
Viene settato quindi l'header della risposta aggiungendo i tre parametri creati,
e si aggiunge l'intestazione \textit{'Access-Control-Allow-Origin': '*',} usata per determinare
se è possibile accedere alla risorsa partendo dal contenuto che opera nell'origine corrente:
\begin{shaded} 
\begin{minted}{js}
res.set({
 'Access-Control-Allow-Origin': '*',
    
 'Status': status,
 'Created_at': created_at,
 'Location': job_id
});              
\end{minted}
\end{shaded}
Infine viene inviata la risposta con status code pari a 201, indicando specificatamente il ``path'' \textit{job\_id} contenuto nell'header (???) inviando un json contenente i vari campi (???).\\
\begin{shaded} 
\begin{minted}{js}
res.status(201).location(job_id).json(request);              
\end{minted}
\end{shaded}
Sempre sullo stesso endpoint si ha anche la query mediante lo \textit{user\_id}, usando il metodo GET:
\begin{shaded} 
\begin{minted}{js}
app.get("/brainjobs-backend/api/v1/jobs", (req, res) => {
  ...
});
\end{minted}
\end{shaded}
Viene settato quindi l'header della risposta con l'intestazione \textit{'Access-Control-Allow-Origin': '*',}
\begin{shaded} 
\begin{minted}{js}
res.set({
  'Access-Control-Allow-Origin': '*'                
});
\end{minted}
\end{shaded}

E si passa quindi alla query al database, mediante prima il \textit{.get(string)}
per selezionare il giusto campo, poi il metodo \textit{.filter(string)} per effettuare
la query selezionando solo quelli che hanno una certa condizione, e la \textit{.value()}
che restiuisce i valori, e all'invio, in formato json della ripsota, con il metodo \textit{.json(string)}
La condizione viene rappresentata mediante la riochiesta che il campo \textit{user\_id} corrisponda allo \textit{user\_id} presente in \textit{req.query}, che sfrutta l'url (da notare il ``?'') \textit{jobs?user\_id=user\_id}:
\begin{shaded} 
\begin{minted}{js}
res.json(db.get('requests')
 .filter({ user_id: req.query.user_id }).value());
\end{minted}
\end{shaded}
Abbiamo infine l'altra GET, quella per ottenere la richiesta corripondente ad un \textit{job\_id}
sull'endpoint dedicato: \textit{/brainjobs-backend/api/v1/jobs/:job\_id\
}. Il principio
è simile a quello dell'altra query solo che useremo il metodo \textit{.find(string)}
per trovare l'unica richiesta co quel dato \textit{job\_id}. Inoltre la query verrà
effettuata mediante il \textit{job\_id} passato nell'endpoint( con il ``:'') al quale
quindi non si accede più con il metodo \textit{query} bensì con quello \textit{params}, che ritorna il nome del parametro quando presente:

\begin{shaded} 
\begin{minted}{js}
app.get("/brainjobs-backend/api/v1/jobs/:job_id", (req, res) =>{    
 res.set({
   'Access-Control-Allow-Origin': '*'
 });
 res.json(db.get('requests')
  .find({ job_id: req.params.job_id }).value());  
});
\end{minted}
\end{shaded}
\chapter{Gateway}
Nell'ultimo punto del progetto si introduce il concetto di API Gateway. L’API Gateway è un componente che, fra le sue funzionalità, maschera la presenza di uno o
più backend alle applicazioni di frontend, occupandosi di esporre una API univoca e di
aggregare, filtrare e comporre richieste/risposte per/da applicazioni di backend.
Nel nostro caso, semplificato, l’API Gateway può replicare per semplicità la stessa API esposta dal
backend ma il suo compito sarà quello di utilizzare internamente un REST Client per
inoltrare le richieste del frontend al backend e restituirne le risposte.\\
Nel complesso si ottiene quindi la seguente archiettura generale:
\begin{figure}[h!]
  \centering
  \includegraphics[scale = 0.68]{img/arch.png}
  \caption{architettura finale del progetto}
\end{figure}
\newpage
Abbiamo la seguente struttura:
\begin{shaded} 
\begin{minted}{shell}
brainjobs-gateway
│   ├── api
           index.js
│   ├── index.js
│   ├── package.json
│   └── package-lock.json
\end{minted}
\end{shaded}
Partiamo, come nel caso del backend, dall'\textit{index.js} presente subito nella cartella
dedicata al gateway. Creaiamo anche qui una istanza con express. Viene anche usato
\textit{body-parse}, \url{https://github.com/expressjs/body-parser}, che parsa il
body della richiesta in un middleware, raggiungibile mediante \textit{req.body},
usando il metodo \textit{.urlencoded({options})} per il parsing di dati nel formato
\textit{application/x-www-urlencoded} e si mette l'istanza in ascolto sulla porta 8080.\\
SI ha una differenza rispetto al backend, infatti qui si inizializza una costante che istanzia un client HTTP basato su \textit{promise}, i quali oggetti rappresentano l'eventuale completamento (o fallimento) di un'operazione asincrona: \textit{axios}, \url{https://github.com/axios/axios}. L'istanza di express e quella di axios vengono passati come parametro all'\textit{index.js} contenuto nella cartella \textit{/api}.\\
Dobbiamo implementare un gateway che effettua un semplice reindirizzamento.\\
Cominciamo con l'inolto di tutte le richieste GET. Si usa il metodo \textit{.get()}
dell'istanza di express. Subito viene definita una variabile contenente l'url a cui
deve essere reindirizzata la GET, ovvero il path attuale della richiesta (recuperabile con \textit{req.originalUrl})
e usando il metodo \textit{replace(a, b)} delle stringhe) con \textit{brainjobs-backend} al posto di \textup{brainjobs-gateway}:
\begin{shaded} 
\begin{minted}{js}
module.exports = function (app, axios) {

  app.get("/brainjobs-gateway/api/v1/*", (req, res) => {

    var redirect = 'http://localhost:8082' +
     req.originalUrl.replace('gateway', 'backend');
    ...
  });
}
\end{minted}
\end{shaded}
Entra quindi in gioco \textit{axios}, a cui vengono passate le opzioni riguardanti il metodo
della richiesta, in questo caso \textit{get}, l'url a cui fare la richiesta, ovvero
l'url del backend che abbiamo appena creato, e il formato della risposta del server,
in questo caso \textit{json}. Con il metodo \textit{.then(function(response))} si
esegue una funzione specifica, nel nostro caso si setta l'header della risposta con
\textit{Access-Control-Allow-Origin *}, permettendo a tutti di accedere alla risorsa
partendo dal contenuto che opera nell'origine corrente. Infine con \textit{res.json(object)} viene inviata la risposta in formato json.\\
xios richiede obbligatoriamente anche di implementare una funzione in caso di errore,
e nel nostro caso consiste nell'invio di un json contenente la specifica dell'errore:
\begin{shaded} 
\begin{minted}{js}
axios({
   method: 'get',
   url: redirect,
   responseType: 'json'
  })
  .then(function (response) {
  
   res.set({
    'Access-Control-Allow-Origin': '*'                
   });
  
   res.json(response.data);

  })
  .catch(function (error) {
   console.log(error);
   res.json({'error': ''+error});
  });       
  
 });

\end{minted}
\end{shaded}
Nell medesimo modo reindirizziamo anche le richieste post, impostando il metodo come \textit{post}, impostando i dati da inviare come quelli contenuti nel body della richiesta, con \textit{req.body}, e settando nell'header il parametro \textit{application/x-www-form-urlencoded} sopra spiegato:
\begin{shaded} 
\begin{minted}{js}
app.post("/brainjobs-gateway/api/v1/*", (req, res) => {

  var redirect = 'http://localhost:8082' +
   req.originalUrl.replace('gateway', 'backend');       
  var forward_data = req.body;

  axios({
   method: 'post',
   url: redirect,
   responseType: 'json',
   headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
   },
   data: forward_data
  })
  .then(function (response) {
  
   res.set({
    'Access-Control-Allow-Origin': '*'                
   });
   
   res.json(response.data);

  })
  .catch(function (error) {
   console.log(error);
   res.json({'error': ''+error});
  });  

});
\end{minted}
\end{shaded}
\textbf{Notiamo come sia nella GET che nella POST viene usata la wildcards ``*'' nell'url per permettere un reindirizzamento completo.}\\
\newpage
In fase di esecuzione si avrà:
\begin{shaded}
\begin{minted}{shell}
brainjobs-backend: node index.js
 Gateway started on: 8080
\end{minted}
\end{shaded}
\chapter{Esecuzione del Progetto}
Per eseguire il progetto bisogna innanzitutto verificare che le 3 porte 8080, 8081 e 8082
siano libere. Bisogna poi spostarsi nelle cartelle brainjobs-backend e brainjobs-gateway e in entrambe eseguire il comando \textit{npm install}:
\begin{shaded} 
\begin{minted}{js}
brainjobs-backend: npm install
 audited 167 packages in 1.767s
 found 0 vulnerabilities

brainjobs-backend: cd ../brainjobs-gateway
brainjobs-gateway: npm install            
 audited 163 packages in 1.611s
 found 0 vulnerabilities        
\end{minted}
\end{shaded}
per installare le eventuali dipendenze elencate nel file \textit{package.json} nella cartella \textit{node\_modules}.
A questo punto bisogna contemporaneamente eseguire i due comandi \textit{node index.js}
all'interno delle cartelle brainjobs-backend e brainjobs-gateway. Un comando comodo
può essere, per non dover aprire più terminali:
\begin{shaded} 
\begin{minted}{bash}
  cd brainjobs-backend ; \
  node index.js & ; \
  cd .. ; \
  cd brainjobs-gateway ; \
  node index.js  
\end{minted}
\end{shaded}
Una seconda alternativa può essere quella di usare un \textit{process manager} per nodejs come \textbf{pm2}, \url{https://github.com/Unitech/PM2}. Dopo averlo installato con:
\begin{shaded} 
\begin{minted}{bash}
  npm install -g pm2
\end{minted}
\end{shaded}
l'uso è simile alla sequenza di comandi data sopra, con la differenza che sarà pm2
ad occuparsi di eseguire il tutto, permettendo eventualmente anche il controllo
dei vari server (nominati con l'opzione \textit{--name}) in esecuzione mediante logs, interfaccia web o monitor tty. Si ha quindi, per esempio:
\begin{shaded} 
\begin{minted}{bash}
  cd brainjobs-backend && \
    pm2 start index.js --name backend && \
    cd .. && \
    cd brainjobs-gateway && \
    pm2 start index.js --name gateway && \
    pm2 logs
\end{minted}
\end{shaded}
\chapter{Docker}
\begin{shaded}
  Docker è un progetto open-source che automatizza il deployment (consegna o rilascio
  al cliente, con relativa installazione e messa in funzione o esercizio, di una
  applicazione o di un sistema software tipicamente all'interno di un sistema informatico aziendale)
  di applicazioni all'interno di contenitori software, fornendo
  un'astrazione aggiuntiva grazie alla virtualizzazione a livello di sistema operativo
  di Linux. Docker utilizza le funzionalità di isolamento delle risorse del kernel
  Linux come ad esempio cgroups e namespaces per consentire a "container" indipendenti
  di coesistere sulla stessa istanza di Linux, evitando l'installazione e la manutenzione di una macchina virtuale. Docker permette di esporre un set di porte desiderato.
\end{shaded}
Realizzare un container per questo progetto è abbastanza veloce, si crea un \textit{dockerfile}
contenente innanzitutto l'immagine da cui si vuole partire. Per nodejs, su dockerhub,
è disponibile l'immagine ufficiale (\url{https://hub.docker.com/_/node}). Si crea
poi una directory su cui lavorare nel container e si copiano le cartelle del prpogetto,
si eseguono i comandi per installare le dipendenze, si espogono le tre porte necessarie
e infine di definisce il comando da eseguire alla fine.
\newpage
Un esempio di dockerfile, usando il metodo di esecuzione con \textit{pm2} è:
\begin{shaded} 
\begin{minted}{docker}
FROM node:10

# Create app directory
WORKDIR /usr/src/app

# Copy folders
COPY brainjobs-backend ./brainjobs-backend
COPY brainjobs-frontend ./brainjobs-frontend
COPY brainjobs-gateway ./brainjobs-gateway

# Install dependences
RUN cd brainjobs-backend && npm install
RUN cd brainjobs-gateway && npm install

# Install Process Manager
RUN npm install -g --silent pm2

# Open ports
EXPOSE 8080 8081 8082

# Start 
CMD cd brainjobs-backend && \
    pm2 start index.js --name backend && \
    cd .. && \
    cd brainjobs-gateway && \
    pm2 start index.js --name gateway && \
    pm2 logs    
\end{minted}
\end{shaded}
Si ha inoltre un file chiamato \textit{.dockerignore} dove si elenano i nomi dei file o delle directory che devono essere ignorati nella fase di COPY. Nel nostro caso le cartelle \textit{node\_modules} in qunto verranno generate da \textit{npm install}, i log e il database in json di \textit{lowdb}, in quanto viene creato automaticamente se assente e settato con dei parametri di default specifici.
\newpage
Si ha quindi un semplice file \textit{.dockerignore}:
\begin{shaded} 
\begin{minted}{docker}
node_modules
npm-debug.log
db.json
\end{minted}
\end{shaded}
Controllando di essere nella directory del \textup{dockerfile} e del \textit{.dockerignore}, buildiamo la nostra immagine con il comando:
\begin{shaded} 
\begin{minted}{bash}
docker build -t brainjobs .
\end{minted}
\end{shaded}
Questa fase impiegherà diversi minuti, sopratutto a causa dell'installazione di \textit{pm2}. Infine eseguiamo l'immagine, specificando che vogliamo lo stesso numero di porta tra quello della macchina fisica e quello esposto dal container:
\begin{shaded} 
\begin{minted}{bash}
docker run  -p 8080:8080 -p 8081:8081 -p 8082:8082 brainjobs
\end{minted}
\end{shaded}
\end{document}